<html class="css-1n8hie0"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/><title>oComponents and You | Mozilla Internet Ecosystem Grant Program Demo</title><link href="/assets/css/bootstrap-reboot.min.css" rel="stylesheet"/><link href="/assets/fontawesome/css/fontawesome-all.min.css" rel="stylesheet"/><link href="/assets/typography.css" rel="stylesheet"/><script src="/assets/fluid-typography.js" data-classes="fluid-content, fluid-title-35, fluid-title"></script><link rel="canonical"/><style>@media (max-width:414px){.css-1n8hie0 .fluid-title-35,.css-1n8hie0 .fluid-title{margin-top:20px;font-weight:300;}}.css-1n8hie0 .margins{margin:0 auto;max-width:760px;padding:0 30px;}@support (padding:max(0px)){.css-1n8hie0 .margins{padding-left:max(30px,env(safe-area-inset-left));padding-right:max(30px,env(safe-area-inset-right));}}.css-1n8hie0 main code.inline{color:rgba(164,115,221,1.0);background:rgba(246,247,252,1.0);font-family:Menlo,Monaco,Consolas,"Courier New",monospace;border-radius:5pt;font-size:0.77em;padding:0.33em .55em;}.css-1n8hie0 main p{margin-bottom:1.2em;}.css-1n8hie0 main h1{font-weight:bolder;font-size:1.2em;}.css-1n8hie0 main h2{margin-top:1em;font-size:1.2em;font-weight:bolder;}.css-1n8hie0 main{position:relative;color:#333;background:white;width:100%;z-index:1;padding-top:3rem;}.css-qv45bh{width:90%;text-align:center;margin:40px auto;}.css-qv45bh img{vertical-align:middle;max-width:100%;}.css-qv45bh figcaption{font-size:0.9rem;font-style:italic;margin-top:10px;color:#555;}</style></head><body><main><div class="margins fluid-content"><div><script src = "https://embed.runkit.com"></script></div><p><figure class="css-qv45bh"><img src="/assets/images/logo.svg" width="139" height="132" alt="RunKit Logo"/><figcaption></figcaption></figure></p>
<h2 style = "text-align:center; font-size:1.4em;">Greetings Mozilla <span style = "text-decoration: line-through;">Builder</span> Internet Ecosystem Grant Program Reviewer!</h2>
<p>The purpose of <strong>oComponents</strong> is to make <i>embedding 3rd party functionality dramatically simpler</i>, so of course I couldn&#x27;t skip the opportunity in my application to give you some interactive examples that do just that!</p><p>In this document I'd like to give you some more in-depth background on <a href = "https://runkit.com/docs/embed">RunKit embeds</a>, the inspiration for <strong>oComponents</strong>, as well as showing you some demos of what a RunKit integration in <a href = "https://developer.mozilla.org/en-US/">MDN Web Docs</a> could look like. Hopefully, this will provide a real-world example of the sorts of experiences that could become more commonplace after <strong>oComponents</strong> makes these sorts of integrations more accessible to publishers and consumers alike.</p>
<h2>Enhancing Server-Side MDN Web Docs</h2>
<p>MDN Web Docs have become the de facto reference manual for the web, and currently do a great job of providing <a href = "https://developer.mozilla.org/en-US/docs/MDN/Structures/Live_samples">interactive documentation</a> for web technologies like (browser) JavaScript, CSS, and HTML. However, MDN has a harder time providing this sort of functionality for server-side technologies.</p>
<p>Whether it's the complementary server-side code needed to fully showcase client-side technologies like <a href = "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications">WebSockets</a>, or even full blown server-side tutorials like this <a href = "https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction">Node.js express tutorial</a>, the existing <i>live samples</i> system unfortunately fails to accomodate these critical components. As described on <a href = "https://developer.mozilla.org/en-US/docs/MDN/Tools/Sample_server">this MDN page</a>, MDN has to fall back to a more traditional documentation style of requiring users to download and install code on their own in order to properly follow along.</p>
<p>The only way to make such tutorials fully interactive would be to immediately provide a real running server to every single user that visits the page... which is exactly what RunKit embeds allow you to do in <strong>endpoint mode</strong>. RunKit can thus fill this gap and give server-side documentation the same first-class treatment as client-side documentation, turning it into fully editable and runnable "live code" on MDN pages. Critically, it could do this without sacrificing the simplicity that documentation authors currently have when using MDN's templating system for making client-side examples.</p>
<h2>Demos!</h2>
<p>As a quick demonstration of the range of possibilities, I've started by taking the existing Node.js Buffer API documentation and given it the "live sample" treatment. Click on the image below to see how Node APIs could be presented as interactively on MDN as the JavaScript DOM APIs are today. Note that each of these examples is running in <strong>real instance of Node</strong>, not being "emulated" on the browser in any way:</p>
<p><a href="/buffer"><figure class="css-qv45bh"><img src="/assets/images/live-documentation.png" alt="Live Documentation Concept"/><figcaption>Node.js Buffer API Documentation with Live Samples</figcaption></figure></a></p>
<p>Similarly, tutorials that need to make use of a live server can do so when RunKit embeds are placed into <strong>endpoint mode</strong>, like expressjs.com's own documentation currently does <a href = "https://expressjs.com/en/starter/hello-world.html">today</a>. MDN can take this a step further by fleshing out more complicated applications. In the example below, not that we are using a wide variety of npm packages, since RunKit has access to every version of every package on npm:</p>
<p><a href="/getting-started"><figure class="css-qv45bh"><img src="/assets/images/getting-started.png" alt="Getting Started Concept"/><figcaption>Tutorials That Let You Create a Real Server Right in Your Web Page</figcaption></figure></a></p>
<h2>How Would oComponents Improve This?</h2>
<p>RunKit provides a very focused slice of functionality: the ability to on-the-fly run any code snippet using any version of Node, accessing any npm package, on a real running server. However, it took a tremendous amount of effort to make this functionality accessible as an embed, simply from a security and performance perspective. While critical to delivering the overall experience, this work was completely orthogonal to any of the core competencies I just listed, and instead revolved entirely around meticulous and obscure interactions between different browser vendors, rarely used edge-case functionality in the DOM, and sometimes even other 3rd party standards like oEmbed (that hasn't been updated in years).</p>
<p>To gives just one example of these challenges, note that all the RunKit embeds load simultaneously in the first demo above. If you were to check the memory monitor, you'd also notice that use minimally more memory than if you were to load just one RunKit embed. This is because RunKit embeds use a sophisticated system where regardless of whether you use 1 or 100 embeds, the "app" itself is only ever loaded in one invisible iframe, that then <i>renders</i> each "embed instance" to a series of empty iframes, treating them almost like canvas elements. This means a host web page will only ever <i>pay the cost" of loading a RunKit embed once</i>, both in terms of speed <i>and</i> memory usage. On the other hand, if you load multiple instances of just about any other iframe-based embed, you'll see the memory use increase linearly, taxing the host page and greatly disincentivizing the liberal use of such components.</p>
<p>Techniques such as these should not be de facto "trade secrets" or "competitive advantages", nor even require arduous re-implementation by every publisher that wishes to provide a completely unrelated service. One of the benefits of a system like oComponents is that it could provide this sort of functionality transparently and allow publishers to focus on what they're good at, vs. becoming experts on browser internals. This would mean a better web for everyone: more dynamic <i>and</i> more performant.</p>
<p>If making your service fit in as cleanly as any same-origin component was as easy writing a same-origin component, I think you could see how more services could go the RunKit route. Circling back to MDN, I think there's opportunities for all sorts of future integrations, not just RunKit. You could easily imagine services like <a href = "browserling.com">browserling.com</a> or <a href = "lambdatest.com">lambdatest.com</a> allowing you to compare the rendering of the current client-side <i>live samples</i> on a wide array of different browsers, <i>without ever needing to leave the documentation page</i>!
<h2>Thanks!</h2>
<p>Hopefully this provides a little more insight into the journey that sparked the idea for <strong>oComponents</strong>. I certainly wish something like this already existed when I started working on RunKit embeds, and given the "prior art" links I provided in the main application, I think I'm not the only one! Please feel free to <a href = "mailto:tolmasky@gmail.com">reach out</a> if you have any questions. Below I've listed a few more sites that currently use RunKit:</p>
    <ul><li><a href="http://npmjs.com">NPM</a></li><li><a href="http://expressjs.com/en/starter/hello-world.html">Express</a></li><li><a href="https://lodash.com/docs/4.17.5">Lodash</a></li><li><a href="https://facebook.github.io/immutable-js/">Facebook Immutable</a></li><li><a href = "https://jhildenbiddle.github.io/docsify-plugin-runkit/#/?id=embedding">Docsify</a></li></ul>
    <p>&mdash; Francisco</p><br><br><br><br>
    </div></main></body></html>